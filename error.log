{"command":{"args":["--[[\n  Adds a job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - if delayed:\n      - computes timestamp.\n      - adds to delayed zset.\n      - Emits a global event 'delayed' if the job is delayed.\n    - if not delayed\n      - Adds the jobId to the wait/paused list in one of three ways:\n         - LIFO\n         - FIFO\n         - prioritized.\n      - Adds the job to the \"added\" list so that workers gets notified.\n    Input:\n      KEYS[1] 'wait',\n      KEYS[2] 'paused'\n      KEYS[3] 'meta-paused'\n      KEYS[4] 'id'\n      KEYS[5] 'delayed'\n      KEYS[6] 'priority'\n      ARGV[1]  key prefix,\n      ARGV[2]  custom id (will not generate one automatically)\n      ARGV[3]  name\n      ARGV[4]  data (json stringified job data)\n      ARGV[5]  opts (json stringified job opts)\n      ARGV[6]  timestamp\n      ARGV[7]  delay\n      ARGV[8]  delayedTimestamp\n      ARGV[9]  priority\n      ARGV[10] LIFO\n      ARGV[11] token\n      ARGV[12] debounce key\n      ARGV[13] debounceId\n      ARGV[14] debounceTtl\n]]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to debounce a job.\n]]\nlocal function debounceJob(prefixKey, debounceId, ttl, jobId, debounceKey, token)\n  if debounceId ~= \"\" then\n    local debounceKeyExists\n    if ttl ~= \"\" then\n      debounceKeyExists = not rcall('SET', debounceKey, jobId, 'PX', ttl, 'NX')\n    else\n      debounceKeyExists = not rcall('SET', debounceKey, jobId, 'NX')\n    end\n    if debounceKeyExists then\n      local currentDebounceJobId = rcall('GET', debounceKey)\n      rcall(\"PUBLISH\", prefixKey .. \"debounced@\" .. token, currentDebounceJobId)\n      return currentDebounceJobId\n    end\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal jobCounter = rcall(\"INCR\", KEYS[4])\nif ARGV[2] == \"\" then\n  jobId = jobCounter\n  jobIdKey = ARGV[1] .. jobId\nelse\n  jobId = ARGV[2]\n  jobIdKey = ARGV[1] .. jobId\n  if rcall(\"EXISTS\", jobIdKey) == 1 then\n    rcall(\"PUBLISH\", ARGV[1] .. \"duplicated@\" .. ARGV[11], jobId)\n    return jobId .. \"\" -- convert to string\n  end\nend\nlocal debounceKey = ARGV[12]\nlocal opts = cmsgpack.unpack(ARGV[5])\nlocal debouncedJobId = debounceJob(ARGV[1], ARGV[13], ARGV[14],\n  jobId, debounceKey, ARGV[11])\nif debouncedJobId then\n  return debouncedJobId\nend\nlocal debounceId = ARGV[13]\nlocal optionalValues = {}\nif debounceId ~= \"\" then\n  table.insert(optionalValues, \"deid\")\n  table.insert(optionalValues, debounceId)\nend\n    -- Store the job.\nrcall(\"HMSET\", jobIdKey, \"name\", ARGV[3], \"data\", ARGV[4], \"opts\", opts, \"timestamp\",\n  ARGV[6], \"delay\", ARGV[7], \"priority\", ARGV[9], unpack(optionalValues))\n-- Check if job is delayed\nlocal delayedTimestamp = tonumber(ARGV[8])\nif(delayedTimestamp ~= 0) then\n  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)\n  rcall(\"ZADD\", KEYS[5], timestamp, jobId)\n  rcall(\"PUBLISH\", KEYS[5], delayedTimestamp)\nelse\n  local target\n  -- Whe check for the meta-paused key to decide if we are paused or not\n  -- (since an empty list and !EXISTS are not really the same)\n  local target, paused = getTargetQueueList(KEYS[3], KEYS[1], KEYS[2])\n  -- Standard or priority add\n  local priority = tonumber(ARGV[9])\n  if priority == 0 then\n      -- LIFO or FIFO\n    rcall(ARGV[10], target, jobId)\n  else\n    addJobWithPriority(KEYS[6], priority, jobId, target)\n  end\n  -- Emit waiting event (wait..ing@token)\n  rcall(\"PUBLISH\", KEYS[1] .. \"ing@\" .. ARGV[11], jobId)\nend\nreturn jobId .. \"\" -- convert to string\n","6","bull:notifications:wait","bull:notifications:paused","bull:notifications:meta-paused","bull:notifications:id","bull:notifications:delayed","bull:notifications:priority","bull:notifications:","a2700adc-538b-47f8-b715-fe8583f0814e","__default__","{\"id\":\"a2700adc-538b-47f8-b715-fe8583f0814e\",\"type\":\"email\",\"payload\":{\"subject\":\"Critical System Alert\",\"body\":\"Database backup failed\",\"from\":\"system@example.com\",\"template\":\"alert-template\"},\"priority\":\"high\",\"timestamp\":\"2024-12-31T18:38:28.412Z\",\"recipient\":\"admin@example.com\",\"status\":\"pending\"}",{"data":[217,180,123,34,97,116,116,101,109,112,116,115,34,58,51,44,34,98,97,99,107,111,102,102,34,58,123,34,116,121,112,101,34,58,34,101,120,112,111,110,101,110,116,105,97,108,34,44,34,100,101,108,97,121,34,58,49,48,48,48,125,44,34,114,101,109,111,118,101,79,110,67,111,109,112,108,101,116,101,34,58,116,114,117,101,44,34,112,114,105,111,114,105,116,121,34,58,49,44,34,106,111,98,73,100,34,58,34,97,50,55,48,48,97,100,99,45,53,51,56,98,45,52,55,102,56,45,98,55,49,53,45,102,101,56,53,56,51,102,48,56,49,52,101,34,44,34,100,101,108,97,121,34,58,48,44,34,116,105,109,101,115,116,97,109,112,34,58,49,55,51,53,54,55,48,51,48,56,52,49,50,125],"type":"Buffer"},"1735670308412","0","0","1","LPUSH","9b265e74-6b31-4224-8969-2bed06d487c9","","",""],"name":"eval"},"level":"error","message":"Error sending notification: MISCONF Redis is configured to save RDB snapshots, but it's currently unable to persist to disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error. script: 27ea40f2e4444b8c0f37ad29529e79e372dbbc82, on @user_script:84.","stack":"ReplyError: MISCONF Redis is configured to save RDB snapshots, but it's currently unable to persist to disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error. script: 27ea40f2e4444b8c0f37ad29529e79e372dbbc82, on @user_script:84.\n    at parseError (C:\\Users\\Youse\\Desktop\\Projects\\Raff Assessment\\NotificationSystem\\node_modules\\redis-parser\\lib\\parser.js:179:12)\n    at parseType (C:\\Users\\Youse\\Desktop\\Projects\\Raff Assessment\\NotificationSystem\\node_modules\\redis-parser\\lib\\parser.js:302:14)","timestamp":"2024-12-31T18:38:28.417Z"}
